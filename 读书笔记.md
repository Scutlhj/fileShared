# 《架构整洁之道》读书笔记

## 前言

架构整洁之道，是作者 Bob 在2016年写的一本书，他在 50 年的工作中得出了一个结论：软件架构的规则是相同的。今天的软件与过去的软件本质上仍然是一样的。都是由 if 语句、赋值语句以及 while 循环组成的。计算机代码没有变化，软件架构的规则也就一直保持了一致。软件架构的规则其实就是排列组合代码块的规则。由于这些代码块本质上没有变化，因此排列组合它们的规则也就不会变化。写这本书就是为了讲述这些规则，这些永恒的、不变的软件架构规则。

## 概述

为什么要考虑软件的架构与设计？好的架构能够有如下优势

- 节省项目构建、维护的人力成本
- 让需求易于实现，只需对项目做很小的变更
- 避免缺陷

也即，用最小的成本，最大程度满足功能性和灵活性的需求。

## 第一章：设计与架构究竟是什么

“架构”这个词往往使用于“高层级”的讨论中。这类讨论一般都把“底层”的实现细节排除在外。而“设计”一词，往往用来指代具体的系统底层组织结构和实现的细节。但是，从一个真正的系统架构师的日常工作来看，这样的区分是根本不成立的。

底层设计细节和高层架构信息是不可分割的。它们组合在一起，共同定义了整个软件系统，缺一不可。所谓的底层和高层本身就是一系列决策组成的连续体，并没有清晰的分界线。

软件架构的终极目标是，用最小的人力成本来满足构建和维护该系统的需求。

## 第二章：两个价值维度

软件系统的两个价值维度：

- 系统行为的正确性：当前系统能否按照预期运行。
- 系统架构的灵活性：需求迭代时，系统更新的难易程度。

两者都很重要，但前者更加紧急，因为系统在每时每刻都要保证行为的正确性；后者虽然不紧急，但很容易被忽略，而忽略的后果很严重，忽略后系统将变得越来越难以维护，终有一天变得无法再修改，只能重构来实现新功能需求。

如果忽视软件架构的价值，系统将会变得越来越难以维护，终会有一天，系统将会变得再也无法修改。如果系统变成了这个样子，那么说明软件开发团队没有和需求方做足够的抗争，没有完成自己应尽的职责。

## 第三章：编程范式总结

编程范式指的是程序的编写模式，与具体的编程语言关系相对较小。这些范式会告诉你应该在什么时候采用什么样的代码结构。直到今天，我们也一共只有三个编程范式，而且未来几乎不可能再出现新的编程范式。

三类编程范式及其意义：

- 结构化编程：对程序控制权的直接转移进行了限制和规范，通俗讲就是限制了goto语句
- 面向对象编程（OOP）：对程序控制权的间接转移进行了限制和规范, 通俗讲就是限制了函数指针，程序就是类及其之间的函数调用
- 函数式编程：对程序中的赋值进行了限制和规范，通俗讲就是限制了赋值语句

每个范式都约束了某种编写代码的方式，明确了什么不应该做。

## 第四章：结构化编程

可以用顺序结构、分支结构、循环结构这三种结构构造出任何程序。

科学方法论不需要证明某条结论是正确的，只需要想办法证明它是错误的。如果某个结论经过一定的努力无法证伪，我们则认为它在当下是足够正确的。

测试只能展示Bug的存在，并不能证明不存在Bug。

软件开发虽然看起来是在操作很多数学结构，其实不是一个数学研究过程。恰恰相反，软件开发更像是一门科学研究学科，我们无法证明软件的正确性。

结构化编程范式促使我们先将一段程序递归降解为一系列可证明的小函数，然后再编写相关的测试来试图证明这些函数是错误的。如果这些测试无法证伪这些函数，那么我们就可以认为这些函数是足够正确的，进而推导整个程序是正确的。

无限制的 goto 语句导致功能/模块无法被递归拆分成更小的部分，所以需要限制。

## 第五章：面向对象编程

### 封装

可以把一组相关联的数据和函数圈起来，使圈外面的代码只能看见部分函数，数据则完全不可见。

而事实上，有很多面向对象编程语言对封装性并没有强制性的要求。

面向对象编程在应用上确实会要求程序员尽量避免破坏数据的封装性。但实际情况是，那些声称自己提供面向对象编程支持的编程语言，相对于C这种完美封装的语言而言，其封装性都被削弱了，而不是加强了。

### 继承

继承的主要作用是让我们可以在某个作用域内对外部定义的某一组变量与函数进行覆盖。

早在面向对象编程语言被发明之前，对继承性的支持就已经存在很久了。当然了，这种支持用了一些投机取巧的手段（书中介绍了 C 语言实现继承的方法，和 js 以前实现继承的思想类似）

面向对象编程在继承性方面并没有开创出新，但是的确在数据结构的伪装性上提供了相当程度的便利性。

### 多态

多态，实质是一种函数指针的应用

在C++中，类中的虚函数地址都被记录在 vtable 的数据结构中。对虚函数的每次调用都要先查询这个表；接口的实现类的构造函数负责将该类的虚函数地址加载到对象的 vtable 中。

如果没有面向对象技术，直接使用函数指针实现多态充满了危险，因为对指针的正确调用需要人为遵守约定，否则会有 bug 或出错。因此，面向对象编程语言为我们消除了人工遵守约定的必要，也就等于消除了这方面的危险性。

通过多态，面向对象编程其实是对程序间接控制权的转移进行了约束。

通过多态，能够实现插件式架构，可以在调用方不做变更情况下，替换底层的实现。

例如，Unix 系统将 IO 设备设计成插件形式，即不同的驱动设备程序只要实现指定的接口，就能被系统调用。

面向对象编程对架构的意义：面向对象编程就是以多态为手段来对源代码中的依赖关系进行控制的能力，这种能力让软件架构师可以构建出某种插件式架构，让高层策略性组件与底层实现性组件相分离，底层组件可以被编译成插件，实现独立于高层组件的开发和部署。

## 第六章：函数式编程

函数式编程语言中的变量（Variable）是不可变（Vary）的。

所有的竞争问题、死锁问题、并发更新问题都是由可变变量导致的。如果变量永远不会被更改，那就不可能产生竞争或者并发更新问题。如果锁状态是不可变的，那就永远不会产生死锁问题。因此软件架构师可以通过限制可变变量来避免竞争问题、死锁问题、并发更新问题。

### 可变性的隔离

一个架构设计良好的应用程序应该将状态修改的部分和不需要修改状态的部分隔离成单独的组件，然后用合适的机制来保护可变量。
软件架构师应该着力于将大部分处理逻辑都归于不可变组件中，可变状态组件的逻辑应该越少越好。

### 不可变性在架构上的应用 —— 事件溯源

银行维护账户余额时，不保存具体账户余额，仅仅保存事务日志，那么当有人想查询账户余额时，我们就将全部交易记录取出，并且每次都得从最开始到当下进行累计。这样就不需要变量了，类似日志重放。

并不需要这个设计永远可行，而且可能在整个程序的生命周期内，我们有足够的存储和处理能力来满足它。

在这种体系下，我们只存储事务记录，不存储具体状态。当需要具体状态时，我们只要从头开始计算所有的事务即可。

## 第七章：SRP（单一职责原则）

SRP 相关解释：
- 每个模块都应该只做一件事
- 一个函数只完成一个功能
- 任何一个软件模块都应该有且仅有一个被修改的原因
- 任何一个软件模块都应该只对某一类行为者负责

## 第八章：OCP（开闭原则）

设计良好的计算机软件应该易于扩展，同时抗拒修改。

设计原则：如果 A 组件不想被 B 组件上发生的修改所影响，那么就应该让 B 组件依赖于 A 组件。

OCP 是我们进行系统架构设计的主导原则，其主要目标是让系统易于扩展，同时限制其每次被修改所影响的范围。实现方式是通过将系统划分为一系列组件，并且将这些组件间的依赖关系按层次结构进行组织，使得高阶组件不会因低阶组件被修改而受到影响。


## 第九章：LSP（里氏替换原则）

子类型必须能够替换掉所有父类型

子类型的定义：如果对于每个类型是S的对象o1都存在一个类型为T的对象o2，能使操作T类型的程序P在用o2替换o1时行为保持不变，我们就可以将S称为T的子类型。

在面向对象这场编程革命兴起的早期，我们的普遍认知认为LSP只不过是指导如何使用继承关系的一种方法，然而随着时间的推移，LSP逐渐演变成了一种更广泛的、指导接口与其实现方式的设计原则。

这里提到的接口可以有多种形式——可以是Java风格的接口，具有多个实现类；也可以像Ruby一样，几个类共用一样的方法签名，甚至可以是几个服务响应同一个REST接口。

LSP适用于上述所有的应用场景，因为这些场景中的用户都依赖于一种接口，并且都期待实现该接口的类之间能具有可替换性。

LSP可以且应该被应用于软件架构层面，因为一旦违背了可替换性，该系统架构就不得不为此增添大量复杂的应对机制。

## 第十章：ISP（接口隔离原则）

任何层次的设计，都不应该依赖它并不需要的东西。

在一般情况下，任何层次的软件设计如果依赖于不需要的东西，都会是有害的。从源代码层次来说，这样的依赖关系会导致不必要的重新编译和重新部署，对更高层次的软件架构设计来说，问题也是类似的。

例如，我们假设某位软件架构师在设计系统S时，想要在该系统中引入某个框架F。这时候，假设框架F的作者又将其捆绑在一个特定的数据库D上，那么就形成了S依赖于F,F又依赖于D的关系。

在这种情况下，如果D中包含了F不需要的功能，那么这些功能同样也会是S不需要的。而我们对D中这些功能的修改将会导致F需要被重新部署，后者又会导致S的重新部署。更糟糕的是，D中一个无关功能的错误也可能会导致F和S运行出错。

## 第十一章：DIP（依赖反转原则）

依赖反转原则(DIP)主要想告诉我们的是，如果想要设计一个灵活的系统，在源代码层次的依赖关系中就应该多引用抽象类型，而非具体实现。

我们每次修改抽象接口的时候，一定也会去修改对应的具体实现。但反过来，当我们修改具体实现时，却很少需要去修改相应的抽象接口。所以我们可以认为接口比实现更稳定。

如果想要在软件架构设计上追求稳定，就必须多使用稳定的抽象接口，少依赖多变的具体实现。下面，我们将该设计原则归结为以下几条具体的编码守则：

- 应在代码中多使用抽象接口，尽量避免使用那些多变的具体实现类。这条守则适用于所有编程语言，无论静态类型语言还是动态类型语言。同时，对象的创建过程也应该受到严格限制，对此，我们通常会选择用抽象工厂（abstract factory）这个设计模式。
- 不要在具体实现类上创建衍生类。上一条守则虽然也隐含了这层意思，但它还是值得被单独拿出来做一次详细声明。在静态类型的编程语言中，继承关系是所有一切源代码依赖关系中最强的、最难被修改的，所以我们对继承的使用应该格外小心。即使是在稍微便于修改的动态类型语言中，这条守则也应该被认真考虑。
- 不要覆盖（override）包含具体实现的函数。调用包含具体实现的函数通常就意味着引入了源代码级别的依赖。即使覆盖了这些函数，我们也无法消除这其中的依赖——这些函数继承了那些依赖关系。在这里，控制依赖关系的唯一办法，就是创建一个抽象函数，然后再为该函数提供多种具体实现。
- 应避免在代码中写入与任何具体实现相关的名字，或者是其他容易变动的事物的名字。这基本上是DIP原则的另外一个表达方式。
