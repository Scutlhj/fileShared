# 《代码大全2》20-26章读书笔记

## 第20章：软件质量概述

### 软件质量的特征

分为外在与内在特征。外在指的是用户能感受到的，内在指的是代码质量
外在特征包括：

- 正确性：实现的功能是否正确
- 可用性：好不好上手
- 效率：内存与执行时间
- 可靠性：无故障时间
- 完整性：阻止未经验证或不正确访问的能力
- 适应性：能否兼容其他环境
- 精确性：结果误差成都
- 健壮性：接受无效输入或处于压力环境时继续运行的能力
  部分特性会存在重叠，不同场合重要性不同

内在特征包括：

- 可维护性：好不好改
- 灵活性：兼容多种环境或不同用途
- 可移植性：适配不同环境的难度
- 可重用性：能否复用代码到其他系统
- 可读性：代码是否可读
- 可测试性
- 可理解性：可读性之上的理解

内在特性会影响外在特性，且部分内在特性间存在冲突

### 改善软件质量的技术

普遍的技术：

- 明确定义软件的质量目标，即应该关注哪些外在质量，并明确规定质量需要保证。目标不能随意变动。
- 测试。
- 需要一套软件构件指南，相当于是一份内部文档，规定了解决哪些问题、采用什么架构、约定哪些编码风格、如何进行测试等。
- 正式与非正式技术复查。

开发过程中：

- 不要毫无节制地变更需求。
- 对结果进行量化。
- 制作原型：相当于设计文档，帮助开发

需要结合多种技术进行改善：Glenford Myers指出，在查找某些特定类型的错误时，人工方法(比如检查和通读代码)往往比用计算机更得心应手，而对另外一些错误类型则正好相反(1979年)。这个结果在后来的一项研究中得到了肯定，该研究发现，阅读代码能够找出较多的接口缺陷，而功能测试则可以检测出更多的控制缺陷(Basili，Selby andHutchens 1986)。

一个错误待的时间越长，修正成本就越大。
另外，人工阅读发现的错误属于“一步到位”型错误，可以直接修改，成本较低；测试发现的错误还需要进行调试分析才能找到，因而成本较高。

### 什么时候需要改善

越早越好

### 软件质量的普遍原理

更高质量的软件不一定会耗费更多时间，反而会节约很多返工的时间。

缺陷最少的软件项目的开发计划时间最短，并拥有最高的开发生产率……消除软件缺陷实际上是最昂贵且最耗时的一种软件工作(Jones 2000)。

## 第21章：协同构建

### 什么是协同开发

“协同构建”包括结对编程、正式检查、非正式技术复查、文档阅读，以及其他让开发人员共同承担创建代码及其他工作产品责任的技术。
各种协同构建技术之间尽管存在着一些差异,但它们都基于一个相同的思想，那就是在工作中开发人员总会对某些错误点视而不见，而其他人不会有相同的点，所以开发人员让其他人来检查自己的工作是很有好处的。

### 结对编程

结对编程的核心思想在于一个人进行编程，另一个人注意检查有没有错误，并考虑设计与策略。

结对编程的关键：

- 要约定代码规范。不要将很多无谓的时间花在纠结代码风格上，而应该尝试对其标准化。
- 不要让结对变成旁观。不掌握键盘的人应该主动积极地检查，并且思考下一步应该做什么。
- 不要强迫在简单的问题上使用结对编程。很多问题可以讨论之后分别编程，或者对部分工作结对编程，而不需要完全结对。
- 有规律地进行人员和工作调换。对于结对双方（驾驶员和领航员）的工作调换，目的在于让双方都能熟悉系统的不同部分，并且合理地分摊工作量。
- 鼓励双方跟上彼此的步伐。
- 保证双方都能看到显示器，而且字体、亮度等应该合适。
- 不要强迫关系不好的人结对。也要避免两个新手结对。
- 如果在团体项目中使用结对方法，也还是需要指定一个组长，来协调工作并对结果负责。

结对编程的好处：

- 结对编程有利于编写高质量代码。
- 结对编程能增加代码的可读性和可维护性。
- 结对编程效率更高，而且错误更少，减少了后期维护需要的投入，从而直接间接地有利于整体进度。

### 正式检查

详查(正式检查)是一种特殊的复查，种种迹象表明它在侦测缺陷方面特别有效，并且相对测试来说更加经济合理。详查关注检测错误，而非急于对其修正。详查者和代码编写者并非一人。

详查的优点：
作者同样给出了数据表明详查能够查出很多错误。另外，通过详查，开发者可以更了解自己现有的方法有什么缺陷，如何改善工作。最后详查还可以用来检查进度。

详查中的人员角色：

- 主持人：负责管理协调各方面工作，安排进度等。
- 作者：主要在代码不够明晰时讲解自己的代码。
- 评论员：负责进行探讨、找出问题。
- 记录员。

一般步骤：

- 概述。作者陈述代码设计及其技术背景。有时候这个阶段可以忽略。
- 准备。各个评论员独立地对代码进行考察。
- 详查会议。挑选某个人阅读代码或者顺序解释代码逻辑，各个评论员提出自己认为的错误并进行讨论。当确认一个错误确实是错误后就停止，而不要纠结于如何改正之类的问题。主持人应该把握节奏，不要太快也不要太慢。
- 详查报告。
- 返工与跟进

对于详查，书中给出了一些小的建议。
首先，可以建立一个核对表，详查过程中提醒评论员尤其注意某些错误。
其次，详查不应该成为代码的公开处刑。应该避免一些过于苛刻的评论，作者也不应该因为自尊心而袒护自己的代码。

### 其他类型的协同开发

#### 走查

与正式检查类似，通常由代码的作者主持。焦点在于技术问题上。和详查一样，重点在于检测错误而非纠正错误。作者对走查的效果较为悲观。好的情况下，走查的效果和详查相近。然而很多情况下，非正式的走查效果很差。对其原因，作者并没有作出解释。不过作者指出，走查尽管非正式，仍然需要很高的成本，所以假如认为复查的需求真的足够迫切，就应该召开正式检查而非走查。否则，应该采用阅读代码等交互性较低的方式。

#### 代码阅读

- 准备阶段：将源代码交给阅读人员。
- 会议阶段：阅读人员指出自己发现的问题并进行讨论。

与详查、走查区别在于，代码阅读注意力集中在发现的问题上，而不需要一行行遍历代码。

## 第22章：开发者测试

分类：

- 单元测试。通常只涉及单个程序员或开发团队。
- 组件测试。似乎和单元测试差不多，不过会涉及多个程序员或开发团队。
- 集成测试。对多个组件进行联合测试，通常应该在有两个可供联合测试的类之后就尽快开始并持续到开发结束。
- 系统测试。主要针对安全、性能、资源消耗、时序、兼容性等问题。

### 测试对软件质量的作用

事实上，测试检查错误的能力没有协同构建高，而且修正成本更高。

### 推荐方法

要点：

- 对模块的每个需求进行测试，对常见的疏漏进行测试。如：安全级别、数据存储、安装过程、系统可靠性。
- 对每个设计的关注点进行测试。
- 基础测试、数据流测试。
- 用检查表记录此前犯过的错误类型。

作者推荐测试先行：

- 测试先行可以将需求先暴露出来，迫使开发者思考一下需求和设计。
- 编码过程中更容易发现缺陷并改正。

开发者测试的局限性：

- 开发者往往更倾向于引入会正确运行的测试样例，而非会出错的测试样例。可能是因为受到了编码思路的限制。
- 开发者容易对覆盖率估计过于乐观，忽略一些更复杂的测试类型。

### 测试技巧锦囊

- 不完整的测试：没有测试能够完整地测试每种情况，所以应该挑选最容易出错误的情况。
- 结构化的基础测试：对于一个程序，至少应该对每个语句测试一次。如果是if或while，应该根据逻辑结构的复杂度增加测试，保证这个语句完全经历了测试。
- 数据流测试：防止出现数据状态出错（如先使用再定义的问题）
- 猜测错误：边界值分析，几类坏数据（如数据太少、数据太多、数据无效、长度错误、数据未初始化等），几类好数据（中间的正常情况、最小的正常情况、最大的正常情况）
- 建议采用容易手工检查的测试数据

### 典型错误

更清晰地了解典型错误有助于我们更高效地查错。

错误同样遵循二八原则，80%的错误存在于项目的20%类或者子程序中，50%的错误存在于5%的类或者子程序中。在编程过程中要对出现的错误进行归纳。

许多错误并非源于构建。常见的其他错误来源：应用领域知识缺乏、频繁更改需求、沟通和协调失效。
作者提出，小型项目中，构建的错误占了绝大多数。就算在大型项目中，构建错误也占了至少35%。对于软件的应用领域了解越清晰，越容易减少错误。

测试本身的错误：测试甚至比生产代码更容易出错，因为书写时可能不那么仔细。
可以用来减少测试的错误的一些方法：检查、开发软件时就要使用测试用例、保留使用过的测试用例、常用单元测试。

## 第23章：调试

### 调试概述

调试是确定错误根本原因并纠正此错误的过程。同测试不同，后者是检测错误的过程。

同测试一样，调试本身并不是改进代码质量的方法，而是诊断代码缺陷的一种方法。

并不是每个人都知道怎么调试。一项研究表明，针对同样一组缺陷，经验丰富的程序员找出缺陷所用的时间大约只是缺乏经验的程序员们的1/20，并且一些程序员能够找出更多的缺陷，且能更为准确地对这些缺陷进行修改。

程序中的错误也会为程序员带来好处：

- 理解正在编写的程序
- 明确自己犯了哪种类型的错误
- 从代码阅读者角度分析代码质量
- 审视自身修复错误的方法

### 寻找缺陷

调试包括了寻找缺陷和修正缺陷。寻找缺陷并且理解缺陷通常占到了整个调试工作的 90%。

科学的调试方法：

- 把错误的发生稳定下来
- 确定错误原因
- 利用可用的工具：如带有提示的编译器
- 缩小嫌疑代码的范围
- 检查最近修改过的代码
- 拓展嫌疑代码的范围
- 同其他人讨论
- 休息一下

### 修正缺陷

调试过程中最让人头疼的部分是寻找缺陷。修正缺陷则是较为简单的部分。但如同很多简单的任务一样，正是因为它太过简单才让人们经常对它掉以轻心。至少已经有一项调查发现程序员在第一次对缺陷进行修正的时候，有超过50%的几率出错。下面给出了减少出错几率的建议：

- 先理解问题再动手
- 验证对错误的分析
- 从本质上解决问题
- 一次只做一个改动
- 添加测试用例
- 搜索类似的缺陷

## 第24章：重构

### 重构的理由

- 代码重复
- 冗长的子程序
- 循环过长或嵌套过深
- 子程序明明不恰当等

### 特定的重构

#### 数据级重构

- 减少魔术数
- 使用更具体的变量名
- 用多个单一变量代替某个多用途变量
- 抽取基础数据类型
- 抽取枚举

#### 语句级重构

- 分解布尔表达式：引入中间变量简化复杂判断
- 抽取布尔函数
- 合并条件语句中的重复代码
- 在 if-else 中尽快返回
- 使用多态替代条件语句

#### 子程序级重构

- 抽取子程序或者方法
- 将冗长程序转换为类
- 用简单算法替代复杂算法
- 将查询操作从修改操作中独立出来

#### 类接口重构

- 将成员函数放到另一个类中
- 将类进行拆分
- 去除中间类调用

### 安全的重构

- 保存初始代码
- 小步重构
- 每次重构完重新运行测试
- 补充新的测试用例
- 检查代码的修改
- 根据风险调整重构方法

不宜重构的情况：

- 不要把重构当做先写后改的代名词：重构最大的问题在于被滥用。程序员们有时会说自己是在重构，而实际上他们所完成的工作仅仅是对无法运行的代码修修补补，希望能让程序跑起来。重构的含义是在不影响程序行为的前提下改进可运行的代码。那些修补破烂代码的程序员们不是在重构，而是在拼凑代码
- 避免用重构代替重写：有时，代码所需要的不是细微修改，而是直接一脚踢出门外，这样你就可以全部重新开始。如果发现自己处于大规模的重构之中，就应该问问自己是否应该把这部分代码推倒重来，重新设计，重新开发。

### 重构策略

- 在增加子程序时进行重构
- 在添加类的时候进行重构
- 在修补缺陷的时候进行重构
- 关注高度复杂与易于出错的模块

## 第25章：代码调整策略

### 性能与代码调整

一旦选择把效率作为头等大事，无论重点是在处理速度还是在处理代码所占用的资源上，你都应该考虑一下其他可能选择，而且应当是在代码一级选择提高速度还是减少资源占用之前去做。请从以下方面来思考效率问题:

- 程序需求：是否是必要的性能问题
- 程序的设计：设计架构时优先考虑整体性能，需要设置具体的目标
- 类和子程序的设计：选用合适的数据结构与算法
- 程序同操作系统的交互：减少不必要的系统交互
- 代码编译：生成高效运行的代码
- 硬件：购买新硬件
- 代码调整

### 代码调整简介

代码调整对应性能优化提示幅度并不大，且高效的代码不等于更好的代码。

Pareto 法则：程序中20%的子程序耗费了80%的执行时间，因此需要找出最需要关注的地方进行调整。

应当何时调整代码：程序完成并正确后。

常见的低效率之源：

- IO操作
- 操作系统分页
- 系统调用
- 解释型语言
- 错误（忘记释放内存等）

### 性能测量

由于程序中某些一小部分常常会耗费同自己体积不成比例的运算时间，所以应当测量代码性能，找出代码中的热点(hotspots)。一旦发现了这样的区域并对该处的代码进行了优化，就再一次进行测量，看看到底有了多少改进。

性能测量应当准确：使用内存，运行时间等可量化数据

### 反复调整

可以结合多种代码调整方式，提升整体性能

反复调整的过程：

1. 用设计良好的代码来开发软件，从而使程序易于理解和修改。
2. 如果程序性能很差。
   a. 保存代码的可运行版本，这样你才能回到“最近的已知正常状态”;
   b.对系统进行分析测量，找出热点;
   c.判断性能拙劣是否源于设计、数据类型或算法上的缺陷，确定是否应该做代码调整
   d.对步骤c中所确定的瓶颈代码进行调整;
   e.每次调整后都对性能提升进行测量;
   f.如果调整没有改进代码的性能，就恢复到步骤a保存的代码(通常而言超过一半的调整尝试都只能稍微改善性能甚至造成性能恶化)。
3. 重复步骤 2。

## 第26章：代码调整技术

### 逻辑

- 在知道答案后停止判断：使用“短路”的方法减少不必要判断
- 按照出现频率调整判断顺序：让运行最快和判断结果最有可能为真的优先执行
- 用查表代替复杂判断
- 使用惰性求值（需要使用时再进行计算，并进行缓存）

### 循环

- 将判断外提
- 合并循环
- 完全展开循环（直接赋值）
- 减少循环内部做的工作
- 将最忙的循环放在最内层

### 数据变换

- 使用整型数而不是浮点数
- 减少数组维度
- 减少对数组访问
- 使用缓存

### 用低级语言重写代码

有一句亘古不变的箴言也不能不提:当程序遭遇性能瓶颈的时候，你应当用低级语言重写代码。如果程序是用C++写的,低级语言或许是汇编;如果是Python写的，那么低级语言可能是C。在低级语言中重新编写代码更有可能改善速度和减少代码规模。下面是使用低级语言优化代码的标准方法。

1. 用高级语言编写整个应用程序。
2. 对程序进行完整的测试，验证其正确性。
3. 如果测试后发现需要改进程序性能:就对程序进行分析，确定出热点。由于5%的程序往往可以占用50%的运行时间，通常你能够将程序中很小的一部分确定为热点。
4. 把几小段代码在低级语言中重写，以此提高整体性能。你是否需要沿着这条充满荆棘的道路走下去，取决于你对低级语言有多么得心应手，相关问题有多么适合使用低级语言来解决，以及你有多大的勇气去冒险。

### 变得越多，事情反而越没变

根据本章的测量结果，比起10年以前，任何特定优化的效果实际上都更加不可预测。每一步代码调整所产生的影响都受制于编程语言、编译器、编译器的版本、代码库、库版本以及编译器设置等各种因素。

代码调整无可避免地为性能改善的良好愿望而付出复杂性、可读性、简单性、可维护性方面的代价。由于每一次调整后需要对性能进行重新评估，代码调整还引入了巨额的管理维护开销。

如果某项优化非常重要，值得为它付出剖析和对优化效果进行量化测量的代价那么只要优化有效，我们还是可以去做的。但是，如果某项优化的重要性不够不值得为它去做效能剖析，那么就不值得为它付出可读性、可维护性和其他代码特性恶化等方面的代价。未经测量的代码优化对性能上的改善充其量是一次投机，然而，其对可读性等产生的负面影响则确凿无疑。
